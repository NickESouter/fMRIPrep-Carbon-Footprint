#Imports relevant modules
import os
import nibabel as nb
import numpy as np

#Defines the pipeline that we want to generate the SD map for. This will need to be updated each time.
pipeline = '0'

#Based on the above variable, finds the directory corresponding to this pipeline which contains fMRIPrep output.
pipeline_dir = '/<directory root>/fMRIPrep/Pipeline_{}/derivatives'.format(pipeline) #Full path removed for purpose of public sharing.

#Creates a variable to store the running sum of SD maps across subjects.
running_sum = None

#This variable will be used to keep track of how many subjects have been iterated over.
count = 0

#Iterates over each subject in the fMRIPrep directory.
for subject in sorted(os.listdir(pipeline_dir)):

    #Ignores a given folder if it doesn't correspond to a specific subject.
    if 'sub' not in subject or 'html' in subject:
        continue

    #1 is added to the subject count.
    count += 1

    #Defines a path containing the functional output data for this subject.
    func_path = os.path.join(pipeline_dir, subject, 'func')

    #Checks for the occurrence of the below strings in this folder. The resolution of
    #the volumetric output space used is accordingly defined as a variable.
    for filename in os.listdir(func_path):
        if 'res-2' in filename:
            resolution = '2'
        elif 'res-1' in filename:
            resolution = '1'    

    #Finds and opens the preprocessed timeseries file.
    timeseries_file = os.path.join(func_path, '{}_task-stopsignal_space-MNI152NLin6Asym_res-{}_desc-preproc_bold.nii.gz'.format(subject, resolution))
    timeseries_load = nb.load(timeseries_file)
    timeseries_raw = timeseries_load.get_fdata()

    #The same is done for the brain mask generated by fMRPrep.
    brain_file = os.path.join(func_path, '{}_task-stopsignal_space-MNI152NLin6Asym_res-{}_desc-brain_mask.nii.gz'.format(subject, resolution))
    brain_load = nb.load(brain_file)
    brain = brain_load.get_fdata()

    #These two arrays are multiplied together, such that the timeseries data is masked by the subject's brain. The 3D array is adjusted
    #to account for the fact it's being multiplied by a 4D array.
    timeseries = timeseries_raw * brain[..., np.newaxis]

    #Calculates the SD of timeseries values within each voxel across the fourth dimension (time) for this subject.
    timeseries_sd = np.std(timeseries, axis=3)

    #Updates the running sum with the current SD map
    if running_sum is None:
        running_sum = timeseries_sd
    else:
        running_sum += timeseries_sd

    #A message is printed, informing the user of the subject ID and the percent of participants now completed (based on total of 257 subjects for this project).
    print("Finished {}, {} subject(s) have been processed.".format(subject, count))

print("Calculating the mean map...")

#Calculates the mean map by dividing the running sum by the number of subjects
mean_map = running_sum / count

#The name of the output file for this pipeline is defined.
output_file = '/<directory root>/SD_Map/P{}_SD_Map_inc.nii.gz'.format(pipeline) #Full path removed for purpose of public sharing.

#Creates a new NIFTI header for the output file given that it's now 3D, not 4D.
header = timeseries_load.header.copy()
header.set_data_shape(mean_map.shape)

#The output file is created and saved.
mean_map_file = nb.Nifti1Image(mean_map, timeseries_load.affine, header)
nb.save(mean_map_file, output_file)
